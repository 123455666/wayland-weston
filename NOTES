
KEYWORDS:

Wayland is a nano display server, relying on drm modesetting, gem
batchbuffer submission and hw initialization generally in the
kernel.  Wayland is compositing manager and display server in one
process.  window management is largely pushed to the clients, they
draw their own decorations and move and resize themselves,
typically implemented in a library.  more of the core desktop could
be pushed into wayland, for example, stock desktop components such
as the panel or the desktop background.

It is still designed with a windowed type of desktop in mind, as
opposed to fullscreen-all-the-time type of interface.

Current trends goes towards less and less rendering in X server, more
hardware setup and management in kernel and shared libraries allow
code sharing without putting it all in a server.  freetype,
fontconfig, cairo all point in this direction, as does direct
rendering mesa.

Client allocates DRM buffers, draws decorations, and full window
contents and posts entire thing to server along with dimensions.

Everything is direct rendered and composited.  No cliprects, no
drawing api/protocl between server and client.  No
pixmaps/windows/drawables, only surfaces (essentially pixmaps).  No
gcs/fonts, no nested windows.  OpenGL is already direct rendered,
pixman may be direct rendered which adds the cairo API, or cairo
may gain a GL backend.

Could be a "shell" for launching gdm X server, user session servers,
safe mode xservers, graphics text console.  From gdm, we could also
launch a rdp session, solid ice sessions.  

All surface commands (copy, attach, map=set quads) are buffered until
the client sends a commit command, which executes everything
atomically...


ISSUES:

Include panel and desktop background in wayland?

How does clients move their surfaces? set a full tri-mesh every time?

How does the server apply transformations to a surface behind the
clients back? (wobbly, minimize, zoom)  Maybe wobble is client side?

How do apps share the glyph cache?

Input handling - keyboard focus, multiple input devices, multiple
pointers, multi touch.

Drawing cursors, moving them, cursor themes, attaching surfaces to
cursors.  How do you change cursors when you mouse over a text
field if you don't have subwindows?

synaptics, 3-button emulation, xkb, scim

changing screen resolution, adding monitors.


RMI

The wayland protocol is a async object oriented protocol.  All
requests are method invocations on some object.  The request include
an object id that uniquely identifies an object on the server.  Each
object implements an interface and the requests include an opcode that
identifies which method in the interface to invoke.

The server sends back events to the client, each event is emitted from
an object.  Events can be error conditions.  The event includes the
object id and the event opcode, from which the client can determine
the type of event.  Events are generated both in repsonse to a request
(in which case the requet and the event constitutes a round trip) or
spontanously when the server state changes.

the get_interface method is called on an object to get an object
handle that implements the specified interface.